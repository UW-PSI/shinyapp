<<<<<<< HEAD
[{"name": "app.py", "content": "from shiny import App, reactive, render, ui\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\n\n\n# Define the available data files and mapping\nriver_files = {\n    \"Pullayup\": \"data/Pullayup\",\n    \"Snohomish\": \"data/Snohomish\",\n    \"Green\": \"data/Green\",\n    \"Samish\": \"data/Sammish\",\n    \"Stillaguamish\": \"data/Stillaguamish\",\n    \"Hoko\": \"data/Hoko\",\n    \"Elwha\": \"data/Elwha\",\n    \"Deschutes\": \"data/Deschutes\"\n}\n\n\n# Pre-load column name options from one sample file\nsample_df = pd.read_csv(river_files[\"Pullayup\"])\n# Exclude \"Year\" and \"Day\"\nvariable_options = [col for col in sample_df.columns if col not in (\"Year\", \"Day\", \"Loop\", \"Step\")]\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hydrologic Timeseries Explorer\"),\n    ui.input_select(\"river\", \"Select River Mouth\", choices=list(river_files.keys())),\n    ui.input_select(\"variable\", \"Select Variable\", choices=variable_options),\n\n    ui.output_plot(\"timeseries_plot\", height=\"500px\"),\n    ui.HTML(\n            '<iframe src=\"https://uwt-gis-geotech.maps.arcgis.com/apps/instant/compare/index.html?appid=63ec7e39e0534386b3fdf0d2ee99f558\" width=\"1100\" height=\"600\" frameborder=\"0\" style=\"border:0\" allowfullscreen></iframe>'\n        )\n)\n\ndef server(input, output, session):\n\n    @reactive.Calc\n    def data():\n        file_path = river_files[input.river()]\n        df = pd.read_csv(file_path)\n        return df\n\n    @reactive.Calc\n    def yearly_summary():\n        df = data()\n        var = input.variable()\n        # Group by year and compute min, max, mean\n        summary = (\n            df.groupby(\"Year\")[var]\n            .agg([\"min\", \"max\", \"mean\"])\n            .reset_index()\n        )\n        return summary\n\n    @output\n    @render.plot\n    def timeseries_plot():\n        summary = yearly_summary()\n        plt.figure(figsize=(10, 5))\n        plt.plot(summary[\"Year\"], summary[\"min\"], label=\"Min\", linestyle=\"--\", color=\"blue\")\n        plt.plot(summary[\"Year\"], summary[\"mean\"], label=\"Mean\", linestyle=\"-\", color=\"green\")\n        plt.plot(summary[\"Year\"], summary[\"max\"], label=\"Max\", linestyle=\"--\", color=\"red\")\n        plt.title(f\"Yearly Summary of {input.variable()} at {input.river()}\")\n        plt.xlabel(\"Year\")\n        plt.ylabel(\"Value\")\n        plt.legend()\n        plt.grid(True)\n        plt.tight_layout()\n        return plt.gcf()\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "explore.py", "content": "import pandas as pd \n\n#read in \"../yr2011_ssm_pnt_wq_velma_T.dat\" as a DataFrame\ndata = pd.read_csv(\n    \"../yr2011_ssm_pnt_wq_velma_T.dat\",\n    header=None,\n    skiprows=2,\n    sep=\"!\",\n    engine=\"python\"\n)\ndata = data.map(lambda x: x.strip() if isinstance(x, str) else x)\nprint(data)\n\n#FUNCTION: Node/Depth (our format) to IJK conversion (Ecology format used with netcdf)\ndef node_depth_to_ijk(node, depth, k_max=10):\n    \"\"\"Convert node number and depth layer to NetCDF IJK index (1-based)\"\"\"\n    ijk = (node - 1) * k_max + depth  #multiply by k_max (10) to get node groups, add depth offset\n    return ijk\n \ndef ijk_to_node_depth(ijk, k_max=10):\n    \"\"\"Convert NetCDF IJK index (1-based) to node number and depth layer\"\"\"\n    node = ((ijk - 1) // k_max) + 1  #integer division: (ijk-1)\u00f710 tells us which group of 10, +1 converts back to 1-based node numbering\n    depth = ((ijk - 1) % k_max) + 1  #modulo operation (position within repeating pattern): (ijk-1) mod 10 gives remainder (0-9), +1 converts to 1-based depth (1-10)\n    return node, depth\n \n# Based on .mat file IJK structure should be that each node gets 10 consecutive IJK numbers (one per depth layer) e.g:\n# Node 1: IJK 1-10    (depths 1-10)\n# Node 2: IJK 11-20   (depths 1-10)  \n# Node 3: IJK 21-30   (depths 1-10)\n# ...\n# Node 101: IJK 1001-1010 (depths 1-10)\n# Formula should work because: IJK = (node-1) \u00d7 10 + depth\n# Example: Node 101, Depth 5 = (101-1) \u00d7 10 + 5 = 1000 + 5 = 1005\n \n# Simple test examples\nprint(\"NetCDF IJK conversion examples:\")\nprint(f\"Node 1, Depth 1 \u2192 IJK {node_depth_to_ijk(1, 1)}\")      #expect 1 (first IJK)\nprint(f\"Node 1, Depth 10 \u2192 IJK {node_depth_to_ijk(1, 10)}\")    #expect 10 (last of first node)\nprint(f\"Node 101, Depth 5 \u2192 IJK {node_depth_to_ijk(101, 5)}\")  #expect 1005 (middle of node 101)\nprint(f\"IJK 1005 \u2192 Node {ijk_to_node_depth(1005)[0]}, Depth {ijk_to_node_depth(1005)[1]}\")  #expect Node 101, Depth 5\n \n# Breakdown of IJK 1005 conversion:\n# (1005-1) \u00f7 10 = 1004 \u00f7 10 = 100 (integer division) \u2192 +1 = Node 101\n# (1005-1) mod 10 = 1004 mod 10 = 4 (remainder) \u2192 +1 = Depth 5", "type": "text"}]
=======
[{"name": "app.py", "content": "from shiny import App, reactive, render, ui\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\n\n# Define the available data files and mapping\nriver_files = {\n    \"Pullayup\": \"data/Pullayup\",\n    \"Snohomish\": \"data/Snohomish\",\n    \"Green\": \"data/Green\",\n    \"Samish\": \"data/Sammish\",\n    \"Stillaguamish\": \"data/Stillaguamish\",\n    \"Hoko\": \"data/Hoko\",\n    \"Elwha\": \"data/Elwha\",\n    \"Deschutes\": \"data/Deschutes\"\n}\n\n\n# Parse to add river entries\ndef parse_velma_dat(filepath):\n    rivers = {}\n    with open(filepath, \"r\") as f:\n        lines = f.readlines()\n        for line in lines:\n            if \"River,\" in line:\n                # Extract river name (after distribution info, before ', River')\n                parts = line.split(',')\n                if len(parts) >= 4:\n                    river_name = parts[2].strip()\n                    # Use the file path for velma.dat with river name as key\n                    rivers[river_name] = filepath\n    return rivers\n\n# velma_rivers = parse_velma_dat(\"../yr2011_ssm_pnt_wq_velma_T.dat\")\n# river_files.update(velma_rivers)\n\n\n\n# Pre-load column name options from one sample file\nsample_df = pd.read_csv(river_files[\"Pullayup\"])\n# Exclude \"Year\" and \"Day\"\nvariable_options = [col for col in sample_df.columns if col not in (\"Year\", \"Day\", \"Loop\", \"Step\")]\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hydrologic Timeseries Explorer\"),\n    ui.input_select(\"river\", \"Select River Mouth\", choices=list(river_files.keys())),\n    ui.input_select(\"variable\", \"Select Variable\", choices=variable_options),\n\n    ui.output_plot(\"timeseries_plot\", height=\"500px\"),\n    ui.HTML(\n            '<iframe src=\"https://uwt-gis-geotech.maps.arcgis.com/apps/instant/compare/index.html?appid=63ec7e39e0534386b3fdf0d2ee99f558\" width=\"1100\" height=\"600\" frameborder=\"0\" style=\"border:0\" allowfullscreen></iframe>'\n        )\n)\n\ndef server(input, output, session):\n\n    @reactive.Calc\n    def data():\n        file_path = river_files[input.river()]\n        df = pd.read_csv(file_path)\n        return df\n\n    @reactive.Calc\n    def yearly_summary():\n        df = data()\n        var = input.variable()\n        # Group by year and compute min, max, mean\n        summary = (\n            df.groupby(\"Year\")[var]\n            .agg([\"min\", \"max\", \"mean\"])\n            .reset_index()\n        )\n        return summary\n\n    @output\n    @render.plot\n    def timeseries_plot():\n        summary = yearly_summary()\n        plt.figure(figsize=(10, 5))\n        plt.plot(summary[\"Year\"], summary[\"min\"], label=\"Min\", linestyle=\"--\", color=\"blue\")\n        plt.plot(summary[\"Year\"], summary[\"mean\"], label=\"Mean\", linestyle=\"-\", color=\"green\")\n        plt.plot(summary[\"Year\"], summary[\"max\"], label=\"Max\", linestyle=\"--\", color=\"red\")\n        plt.title(f\"Yearly Summary of {input.variable()} at {input.river()}\")\n        plt.xlabel(\"Year\")\n        plt.ylabel(\"Value\")\n        plt.legend()\n        plt.grid(True)\n        plt.tight_layout()\n        return plt.gcf()\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "explore.py", "content": "import pandas as pd \n\n#read in \"../yr2011_ssm_pnt_wq_velma_T.dat\" as a DataFrame\ndata = pd.read_csv(\n    \"../yr2011_ssm_pnt_wq_velma_T.dat\",\n    header=None,\n    skiprows=2,\n    sep=\"!\",\n    engine=\"python\"\n)\ndata = data.map(lambda x: x.strip() if isinstance(x, str) else x)\nprint(data.)", "type": "text"}]
>>>>>>> bf9ed00fb7c5eee8f4b8ef415e9745a37a2e0af9
